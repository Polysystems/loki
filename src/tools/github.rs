use std::sync::Arc;

use anyhow::{Context as AnyhowContext, Result};
use octocrab::Octocrab;
use serde::{Deserialize, Serialize};
use tracing::{debug, info};

use crate::cognitive::self_modify::{CodeChange, PullRequest};
use crate::memory::{CognitiveMemory, MemoryMetadata};

/// GitHub configuration
#[derive(Debug, Clone)]
pub struct GitHubConfig {
    pub token: String,
    pub owner: String,
    pub repo: String,
    pub default_branch: String,
}

impl GitHubConfig {
    /// Load from environment variables
    pub fn from_env() -> Result<Self> {
        Ok(Self {
            token: std::env::var("GITHUB_TOKEN")
                .context("GITHUB_TOKEN environment variable not set")?,
            owner: std::env::var("GITHUB_OWNER")
                .context("GITHUB_OWNER environment variable not set")?,
            repo: std::env::var("GITHUB_REPO")
                .context("GITHUB_REPO environment variable not set")?,
            default_branch: std::env::var("GITHUB_DEFAULT_BRANCH")
                .unwrap_or_else(|_| "main".to_string()),
        })
    }
}

/// GitHub client with self-modification capabilities
#[derive(Debug)]
pub struct GitHubClient {
    /// Octocrab client
    client: Arc<Octocrab>,

    /// Configuration
    config: GitHubConfig,

    /// Memory system
    memory: Arc<CognitiveMemory>,
}

impl GitHubClient {
    /// Create a new GitHub client
    pub async fn new(config: GitHubConfig, memory: Arc<CognitiveMemory>) -> Result<Self> {
        info!("Initializing GitHub client for {}/{}", config.owner, config.repo);

        let client = Octocrab::builder().personal_token(config.token.clone()).build()?;

        Ok(Self { client: Arc::new(client), config, memory })
    }

    /// Create a pull request from a code change
    pub async fn create_pull_request(
        &self,
        branch_name: String,
        change: CodeChange,
    ) -> Result<PullRequest> {
        info!("Creating PR for branch: {}", branch_name);

        // Create the PR using Octocrab
        let pr = self
            .client
            .pulls(&self.config.owner, &self.config.repo)
            .create(&change.description, &branch_name, &self.config.default_branch)
            .body(&self.format_pr_body(&change))
            .send()
            .await?;

        let pull_request = PullRequest {
            number: pr.number as u32,
            title: change.description.clone(),
            description: self.format_pr_body(&change),
            branch: branch_name,
            status: crate::cognitive::self_modify::PullRequestStatus::Open,
        };

        // Store in memory
        self.memory
            .store(
                format!("Created PR #{}: {}", pr.number, change.description),
                vec![format!("PR URL: {}", pr.html_url.as_ref().map(|u| u.as_str()).unwrap_or(""))],
                MemoryMetadata {
                    source: "github".to_string(),
                    tags: vec!["pull_request".to_string(), "self_modification".to_string()],
                    importance: 0.9,
                    associations: vec![],

                    context: Some("Generated from automated fix".to_string()),
                    created_at: chrono::Utc::now(),
                    accessed_count: 0,
                    last_accessed: None,
                    version: 1,
                    category: "tool_usage".to_string(),
                    timestamp: chrono::Utc::now(),
                    expiration: None,
                },
            )
            .await?;

        Ok(pull_request)
    }

    /// Format PR body with all relevant information
    fn format_pr_body(&self, change: &CodeChange) -> String {
        format!(
            r#"## ðŸ¤– Autonomous Code Change

### Description
{}

### Reasoning
{}

### Risk Level
{:?}

### Change Type
{:?}

### Files Modified
- `{}`

### Generated by Loki
This pull request was automatically generated by the Loki autonomous coding system.

---
*Loki v1 - Building consciousness, one commit at a time*"#,
            change.description,
            change.reasoning,
            change.risk_level,
            change.change_type,
            change.file_path.display()
        )
    }

    /// Get file contents from repository
    pub async fn get_file_contents(&self, path: &str, branch: Option<&str>) -> Result<String> {
        let branch = branch.unwrap_or(&self.config.default_branch);

        debug!("Fetching file contents: {} from branch: {}", path, branch);

        let content = self
            .client
            .repos(&self.config.owner, &self.config.repo)
            .get_content()
            .path(path)
            .r#ref(branch)
            .send()
            .await?;

        if let Some(content) = content.items.first() {
            if let Some(decoded) = content.decoded_content() {
                return Ok(decoded);
            }
        }

        Err(anyhow::anyhow!("Failed to decode file contents"))
    }

    /// List repository files
    pub async fn list_files(&self, path: &str) -> Result<Vec<String>> {
        debug!("Listing files in: {}", path);

        let contents = self
            .client
            .repos(&self.config.owner, &self.config.repo)
            .get_content()
            .path(path)
            .send()
            .await?;

        Ok(contents.items.into_iter().map(|item| item.path).collect())
    }

    /// Check if PR is ready to merge
    pub async fn check_pr_status(&self, pr_number: u32) -> Result<bool> {
        let pr =
            self.client.pulls(&self.config.owner, &self.config.repo).get(pr_number as u64).await?;

        // Check if all checks have passed
        if let Some(mergeable) = pr.mergeable { Ok(mergeable) } else { Ok(false) }
    }

    /// Merge a pull request
    pub async fn merge_pr(&self, pr_number: u32, merge_method: &str) -> Result<()> {
        use octocrab::params::pulls::MergeMethod;

        info!("Merging PR #{} using method: {}", pr_number, merge_method);

        let method = match merge_method {
            "squash" => MergeMethod::Squash,
            "rebase" => MergeMethod::Rebase,
            _ => MergeMethod::Merge,
        };

        self.client
            .pulls(&self.config.owner, &self.config.repo)
            .merge(pr_number as u64)
            .method(method)
            .send()
            .await?;

        // Store in memory
        self.memory
            .store(
                format!("Merged PR #{}", pr_number),
                vec![],
                MemoryMetadata {
                    source: "github".to_string(),
                    tags: vec!["merge".to_string(), "success".to_string()],
                    importance: 0.8,
                    associations: vec![],

                    context: Some("Generated from automated fix".to_string()),
                    created_at: chrono::Utc::now(),
                    accessed_count: 0,
                    last_accessed: None,
                    version: 1,
                    category: "tool_usage".to_string(),
                    timestamp: chrono::Utc::now(),
                    expiration: None,
                },
            )
            .await?;

        Ok(())
    }

    /// Create an issue
    pub async fn create_issue(&self, title: &str, body: &str, labels: Vec<String>) -> Result<u32> {
        let issue = self
            .client
            .issues(&self.config.owner, &self.config.repo)
            .create(title)
            .body(body)
            .labels(labels)
            .send()
            .await?;

        Ok(issue.number as u32)
    }

    /// Get pull request details
    pub async fn get_pull_request(&self, pr_number: u32) -> Result<PullRequestDetails> {
        debug!("Fetching PR #{} details", pr_number);

        let pr = self
            .client
            .pulls(&self.config.owner, &self.config.repo)
            .get(pr_number as u64)
            .await
            .with_context(|| format!("Failed to fetch PR #{}", pr_number))?;

        // Get PR status checks (simplified for now)
        let status = PullRequestStatus::Unknown;

        let pr_details = PullRequestDetails {
            number: pr.number as u32,
            title: pr.title.unwrap_or_default(),
            body: pr.body.unwrap_or_default(),
            state: match pr.state {
                Some(octocrab::models::IssueState::Open) => PRState::Open,
                Some(octocrab::models::IssueState::Closed) => {
                    if pr.merged_at.is_some() {
                        PRState::Merged
                    } else {
                        PRState::Closed
                    }
                }
                None => PRState::Open,    // Default to open if unknown
                Some(_) => PRState::Open, // Catch-all for any other states
            },
            head_branch: pr.head.ref_field,
            base_branch: pr.base.ref_field,
            mergeable: pr.mergeable.unwrap_or(false),
            status_checks: status,
            created_at: pr.created_at.unwrap_or_else(|| chrono::Utc::now()),
            updated_at: pr.updated_at.unwrap_or_else(|| chrono::Utc::now()),
            merged_at: pr.merged_at,
            author: pr
                .user
                .as_ref()
                .map(|u| u.login.clone())
                .unwrap_or_else(|| "unknown".to_string()),
            url: pr.html_url.map(|u| u.to_string()).unwrap_or_else(|| "".to_string()),
        };

        // Store access in memory for tracking
        self.memory
            .store(
                format!("Accessed PR #{}: {}", pr_number, pr_details.title),
                vec![
                    format!("State: {:?}", pr_details.state),
                    format!("Author: {}", pr_details.author),
                    format!("Status: {:?}", pr_details.status_checks),
                ],
                MemoryMetadata {
                    source: "github".to_string(),
                    tags: vec!["pull_request".to_string(), "status_check".to_string()],
                    importance: 0.6,
                    associations: vec![],

                    context: Some("Generated from automated fix".to_string()),
                    created_at: chrono::Utc::now(),
                    accessed_count: 0,
                    last_accessed: None,
                    version: 1,
                    category: "tool_usage".to_string(),
                    timestamp: chrono::Utc::now(),
                    expiration: None,
                },
            )
            .await?;

        Ok(pr_details)
    }

    /// Get repository statistics
    pub async fn get_repo_stats(&self) -> Result<RepoStats> {
        let repo = self.client.repos(&self.config.owner, &self.config.repo).get().await?;

        Ok(RepoStats {
            stars: repo.stargazers_count.unwrap_or(0) as u32,
            forks: repo.forks_count.unwrap_or(0) as u32,
            open_issues: repo.open_issues_count.unwrap_or(0) as u32,
            watchers: repo.watchers_count.unwrap_or(0) as u32,
        })
    }

    /// Comment on a pull request
    pub async fn comment_on_pr(&self, pr_number: u32, comment: &str) -> Result<()> {
        info!("Commenting on PR #{}: {}", pr_number, comment);
        
        // Use the Octocrab client to post a comment on the specified pull request
        self.client
            .issues(&self.config.owner, &self.config.repo)
            .create_comment(pr_number as u64, comment)
            .await
            .context("Failed to create PR comment")?;
            
        // Store the action in memory for tracking
        let metadata = MemoryMetadata {
            source: "github_pr_comment".to_string(),
            tags: vec![
                "github".to_string(),
                "pr".to_string(),
                format!("pr_{}", pr_number),
                "comment".to_string(),
            ],
            importance: 0.7,
            ..Default::default()
        };
        
        self.memory
            .store(
                format!("github_pr_comment_{}", pr_number),
                vec![
                    format!("pr_number: {}", pr_number),
                    format!("comment: {}", comment),
                ],
                metadata,
            )
            .await?;
            
        info!("Successfully commented on PR #{}", pr_number);
        Ok(())
    }
}

/// Story-driven PR review functionality
pub struct StoryDrivenPrReview {
    /// GitHub client
    github_client: Arc<GitHubClient>,
    
    /// Story engine reference
    story_engine: Option<Arc<crate::story::StoryEngine>>,
    
    /// Memory system
    memory: Arc<CognitiveMemory>,
}

impl StoryDrivenPrReview {
    /// Create new story-driven PR reviewer
    pub fn new(
        github_client: Arc<GitHubClient>,
        memory: Arc<CognitiveMemory>,
    ) -> Self {
        Self {
            github_client,
            story_engine: None,
            memory,
        }
    }
    
    /// Set story engine
    pub fn set_story_engine(&mut self, story_engine: Arc<crate::story::StoryEngine>) {
        self.story_engine = Some(story_engine);
    }
    
    /// Review PR with story context
    pub async fn review_pr_with_story(&self, pr_number: u32) -> Result<PrReviewResult> {
        info!("Starting story-driven review of PR #{}", pr_number);
        
        // Get PR details
        let pr_details = self.github_client.get_pull_request(pr_number).await?;
        
        // Get story context if available
        let story_context = if let Some(ref story_engine) = self.story_engine {
            Some(story_engine.get_current_context().await?.into())
        } else {
            None
        };
        
        // Generate review based on story arc
        let review = self.generate_story_aware_review(&pr_details, story_context.clone()).await?;
        
        // Post review comment
        self.github_client.comment_on_pr(pr_number, &review.comment).await?;
        
        // Update story if engine is available
        if let Some(ref story_engine) = self.story_engine {
            if let Some(context) = story_context {
                // Add PR review to story
                let plot_type = crate::story::PlotType::Task {
                    description: format!("Reviewed PR #{}: {}", pr_number, pr_details.title),
                    completed: true,
                };
                
                story_engine.add_plot_point(
                    context.story_id,
                    plot_type,
                    vec!["pr-review".to_string()],
                ).await?;
            }
        }
        
        // Store review in memory
        self.memory.store(
            format!("Story-driven review of PR #{}", pr_number),
            vec![
                format!("Review sentiment: {:?}", review.sentiment),
                format!("Narrative alignment: {:.0}%", review.narrative_alignment * 100.0),
            ],
            MemoryMetadata {
                source: "story_pr_review".to_string(),
                tags: vec!["pr_review".to_string(), "story_driven".to_string()],
                importance: 0.8,
                associations: vec![],
                context: Some("Story-aware PR review".to_string()),
                created_at: chrono::Utc::now(),
                accessed_count: 0,
                last_accessed: None,
                version: 1,
                category: "review".to_string(),
                timestamp: chrono::Utc::now(),
                expiration: None,
            },
        ).await?;
        
        Ok(review)
    }
    
    /// Generate story-aware review
    async fn generate_story_aware_review(
        &self,
        pr: &PullRequestDetails,
        story_context: Option<crate::story::StoryContext>,
    ) -> Result<PrReviewResult> {
        let mut review = PrReviewResult {
            comment: String::new(),
            sentiment: ReviewSentiment::Neutral,
            narrative_alignment: 0.5,
            suggestions: Vec::new(),
        };
        
        // Base review content
        review.comment = format!("## ðŸ“– Story-Driven Review of PR #{}\n\n", pr.number);
        review.comment.push_str(&format!("**Title:** {}\n\n", pr.title));
        
        // Add story context if available
        if let Some(context) = story_context {
            review.comment.push_str("### ðŸŽ­ Narrative Context\n\n");
            review.comment.push_str(&format!("**Narrative:** {}\n", context.narrative));
            
            if let Some(arc) = &context.active_arc {
                review.comment.push_str(&format!("**Story Arc:** {}\n", arc.title));
                
                // Adjust review sentiment based on arc type
                review.sentiment = match arc.title.to_lowercase().as_str() {
                    "conflict" => ReviewSentiment::Critical,
                    "resolution" => ReviewSentiment::Supportive,
                    "climax" => ReviewSentiment::Enthusiastic,
                    _ => ReviewSentiment::Neutral,
                };
                
                // Calculate narrative alignment
                review.narrative_alignment = self.calculate_narrative_alignment(&pr.title, &[arc.description.clone()]);
            }
            
            review.comment.push_str(&format!("\n**Narrative Alignment:** {:.0}%\n\n", 
                review.narrative_alignment * 100.0));
        }
        
        // Add review content based on sentiment
        review.comment.push_str("### ðŸ“ Review Comments\n\n");
        
        match review.sentiment {
            ReviewSentiment::Enthusiastic => {
                review.comment.push_str("ðŸŽ‰ This PR beautifully advances our narrative! ");
                review.comment.push_str("The changes align perfectly with our current story arc.\n\n");
                review.suggestions.push("Consider documenting this milestone in our story log".to_string());
            }
            ReviewSentiment::Supportive => {
                review.comment.push_str("âœ… Good progress on this implementation. ");
                review.comment.push_str("The changes support our narrative goals.\n\n");
                review.suggestions.push("Let's ensure this integrates well with upcoming plot points".to_string());
            }
            ReviewSentiment::Neutral => {
                review.comment.push_str("ðŸ” Reviewing this PR in the context of our ongoing development story.\n\n");
                review.suggestions.push("Consider how this change affects our narrative flow".to_string());
            }
            ReviewSentiment::Critical => {
                review.comment.push_str("âš ï¸ This change requires careful consideration ");
                review.comment.push_str("given our current narrative tension.\n\n");
                review.suggestions.push("Ensure thorough testing given the critical nature of this arc".to_string());
            }
        }
        
        // Add suggestions
        if !review.suggestions.is_empty() {
            review.comment.push_str("### ðŸ’¡ Suggestions\n\n");
            for suggestion in &review.suggestions {
                review.comment.push_str(&format!("- {}\n", suggestion));
            }
        }
        
        // Add closing
        review.comment.push_str("\n---\n");
        review.comment.push_str("*Generated by Loki's Story-Driven Review System* ðŸ¤–ðŸ“š\n");
        
        Ok(review)
    }
    
    /// Calculate how well PR aligns with narrative
    fn calculate_narrative_alignment(&self, pr_title: &str, objectives: &[String]) -> f32 {
        let pr_lower = pr_title.to_lowercase();
        let mut alignment_score = 0.0;
        let mut matches = 0;
        
        for objective in objectives {
            let obj_lower = objective.to_lowercase();
            
            // Check for keyword matches
            for word in obj_lower.split_whitespace() {
                if pr_lower.contains(word) && word.len() > 3 {
                    matches += 1;
                }
            }
        }
        
        if !objectives.is_empty() {
            alignment_score = matches as f32 / (objectives.len() * 3) as f32;
            alignment_score = alignment_score.min(1.0);
        }
        
        // Base alignment of 0.3 for any PR
        (0.3 + alignment_score * 0.7).min(1.0)
    }
}

/// PR review result
#[derive(Debug, Clone)]
pub struct PrReviewResult {
    pub comment: String,
    pub sentiment: ReviewSentiment,
    pub narrative_alignment: f32,
    pub suggestions: Vec<String>,
}

/// Review sentiment based on story context
#[derive(Debug, Clone, Copy)]
pub enum ReviewSentiment {
    Enthusiastic,
    Supportive,
    Neutral,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RepoStats {
    pub stars: u32,
    pub forks: u32,
    pub open_issues: u32,
    pub watchers: u32,
}

/// Detailed pull request information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PullRequestDetails {
    pub number: u32,
    pub title: String,
    pub body: String,
    pub state: PRState,
    pub head_branch: String,
    pub base_branch: String,
    pub mergeable: bool,
    pub status_checks: PullRequestStatus,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    pub author: String,
    pub url: String,
}

/// Pull request state
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum PRState {
    Open,
    Closed,
    Merged,
}

/// Pull request status check result
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum PullRequestStatus {
    Success,
    Failure,
    Error,
    Pending,
    Unknown,
}
